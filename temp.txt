description: "Auto-scale Lambda provisioned concurrency based on usage"
schemaVersion: '0.3'
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  FunctionName:
    type: String
    description: "The name of the Lambda function"
  Alias:
    type: String
    description: "The alias of the Lambda function (e.g., prod)"
  MinConcurrency:
    type: Integer
    default: 1
    description: "Minimum provisioned concurrency"
  MaxConcurrency:
    type: Integer
    default: 10
    description: "Maximum provisioned concurrency"
  AutomationAssumeRole:
    type: String
    description: "The IAM role ARN to assume during execution"

mainSteps:
  - name: GetTimestamps
    action: aws:executeScript
    inputs:
      Runtime: python3.8
      Handler: handler
      Script: |
        import datetime
        def handler(event, context):
            now = datetime.datetime.utcnow()
            start = now - datetime.timedelta(minutes=15)
            return {
              "StartTime": start.isoformat(),
              "EndTime": now.isoformat()
            }
    outputs:
      - Name: StartTime
        Selector: $.Payload.StartTime
        Type: String
      - Name: EndTime
        Selector: $.Payload.EndTime
        Type: String

  - name: GetAverageUsage
    action: aws:executeAwsApi
    inputs:
      Service: cloudwatch
      Api: GetMetricStatistics
      Namespace: AWS/Lambda
      MetricName: ConcurrentExecutions
      Dimensions:
        - Name: FunctionName
          Value: "{{ FunctionName }}"
        - Name: Resource
          Value: "{{ FunctionName }}:{{ Alias }}"
      StartTime: "{{ GetTimestamps.StartTime }}"
      EndTime: "{{ GetTimestamps.EndTime }}"
      Period: 60
      Statistics:
        - Average
    outputs:
      - Name: avgUsage
        Selector: $.Datapoints[0].Average
        Type: String

  - name: GetCurrentProvisioned
    action: aws:executeAwsApi
    inputs:
      Service: lambda
      Api: GetProvisionedConcurrencyConfig
      FunctionName: "{{ FunctionName }}"
      Qualifier: "{{ Alias }}"
    outputs:
      - Name: currentProvisioned
        Selector: $.RequestedProvisionedConcurrentExecutions
        Type: String

  - name: DecideAndScale
    action: aws:executeScript
    inputs:
      Runtime: python3.8
      Handler: handler
      Script: |
        def handler(events, context):
            try:
                usage = float(events["GetAverageUsage"]["avgUsage"])
            except:
                usage = 0.0

            try:
                provisioned = int(events["GetCurrentProvisioned"]["currentProvisioned"])
            except:
                provisioned = 1

            min_c = int(events["MinConcurrency"])
            max_c = int(events["MaxConcurrency"])

            if usage >= 0.9 * provisioned and provisioned < max_c:
                new_val = provisioned + 1
            elif usage < 0.5 * provisioned and provisioned > min_c:
                new_val = provisioned - 1
            else:
                new_val = provisioned

            return {"newValue": str(new_val)}
    outputs:
      - Name: newValue
        Selector: $.Payload.newValue
        Type: String

  - name: SetNewProvisioned
    action: aws:executeAwsApi
    inputs:
      Service: lambda
      Api: PutProvisionedConcurrencyConfig
      FunctionName: "{{ FunctionName }}"
      Qualifier: "{{ Alias }}"
      ProvisionedConcurrentExecutions: "{{ DecideAndScale.newValue }}"
