description: "Auto-scale Lambda provisioned concurrency based on usage"
schemaVersion: '0.3'
assumeRole: "{{ AutomationAssumeRole }}"
parameters:
  FunctionName:
    type: String
    description: "Lambda function name"
  Alias:
    type: String
    description: "Lambda alias (e.g., prod)"
  MinConcurrency:
    type: Integer
    default: 1
    description: "Minimum allowed provisioned concurrency"
  MaxConcurrency:
    type: Integer
    default: 10
    description: "Maximum allowed provisioned concurrency"
  AutomationAssumeRole:
    type: String
    description: "IAM role to assume"

mainSteps:
  - name: GetAverageUsage
    action: aws:executeAwsApi
    inputs:
      Service: cloudwatch
      Api: GetMetricStatistics
      Namespace: AWS/Lambda
      MetricName: ConcurrentExecutions
      Dimensions:
        - Name: FunctionName
          Value: "{{ FunctionName }}"
        - Name: Resource
          Value: "{{ FunctionName }}:{{ Alias }}"
      StartTime: "{{ aws:timestamp(-900) }}"
      EndTime: "{{ aws:timestamp() }}"
      Period: 60
      Statistics:
        - Average
    outputs:
      - Name: avgUsage
        Selector: $.Datapoints[0].Average
        Type: String

  - name: GetCurrentProvisioned
    action: aws:executeAwsApi
    inputs:
      Service: lambda
      Api: GetProvisionedConcurrencyConfig
      FunctionName: "{{ FunctionName }}"
      Qualifier: "{{ Alias }}"
    outputs:
      - Name: currentProvisioned
        Selector: $.RequestedProvisionedConcurrentExecutions
        Type: String

  - name: CalculateNewValue
    action: aws:executeScript
    inputs:
      Runtime: python3.8
      Handler: handler
      Script: |
        def handler(events, context):
            try:
                usage = float(events["GetAverageUsage"]["avgUsage"])
            except (TypeError, ValueError):
                usage = 0.0

            try:
                provisioned = int(events["GetCurrentProvisioned"]["currentProvisioned"])
            except (TypeError, ValueError):
                provisioned = 1

            min_c = int(events["MinConcurrency"])
            max_c = int(events["MaxConcurrency"])

            if usage >= 0.9 * provisioned and provisioned < max_c:
                new_val = min(provisioned + 1, max_c)
            elif usage < 0.5 * provisioned and provisioned > min_c:
                new_val = max(provisioned - 1, min_c)
            else:
                new_val = provisioned

            return { "newValue": str(new_val) }
    outputs:
      - Name: newValue
        Selector: $.Payload.newValue
        Type: String

  - name: ApplyScaling
    action: aws:executeAwsApi
    inputs:
      Service: lambda
      Api: PutProvisionedConcurrencyConfig
      FunctionName: "{{ FunctionName }}"
      Qualifier: "{{ Alias }}"
      ProvisionedConcurrentExecutions: "{{ CalculateNewValue.newValue }}"
